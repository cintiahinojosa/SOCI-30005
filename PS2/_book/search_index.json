[
["intro.html", "2 Intro 2.1 CSIW Dataset 2.2 Variables 2.3 Missingness report 2.4 Codebook table", " 2 Intro csiw &lt;- read_sav(&quot;csiw_new.sav&quot;) names(csiw) ## [1] &quot;school&quot; &quot;teacher&quot; &quot;id&quot; &quot;group&quot; &quot;treatmt&quot; ## [6] &quot;cch1&quot; &quot;cch2&quot; &quot;pre_test&quot; &quot;post_test&quot; &quot;ccprod1&quot; ## [11] &quot;ccprod2&quot; &quot;ccrdr1&quot; &quot;ccrdr2&quot; &quot;grade&quot; &quot;CSIW&quot; 2.1 CSIW Dataset CSIW (treatmt) 1=CSIW 0=control Achievement Level () 1=High 2=Average 3=Low 4=Learning Disability Holistic pretest pre-test on writing achievement Holistic posttest () post-test on writing achievement Grade (grade) 1=Grade 4 2=Grade 5 names(csiw) ## [1] &quot;school&quot; &quot;teacher&quot; &quot;id&quot; &quot;group&quot; &quot;treatmt&quot; ## [6] &quot;cch1&quot; &quot;cch2&quot; &quot;pre_test&quot; &quot;post_test&quot; &quot;ccprod1&quot; ## [11] &quot;ccprod2&quot; &quot;ccrdr1&quot; &quot;ccrdr2&quot; &quot;grade&quot; &quot;CSIW&quot; summary(csiw) ## school teacher id group ## Min. : 1.000 Min. : 1.00 Min. : 1.00 Min. :1.000 ## 1st Qu.: 1.000 1st Qu.: 4.00 1st Qu.:20.00 1st Qu.:2.000 ## Median : 2.000 Median : 8.00 Median :35.00 Median :3.000 ## Mean : 4.509 Mean :10.91 Mean :32.12 Mean :2.659 ## 3rd Qu.: 9.000 3rd Qu.:18.00 3rd Qu.:44.00 3rd Qu.:4.000 ## Max. :13.000 Max. :55.00 Max. :61.00 Max. :4.000 ## NA&#39;s :40 ## treatmt cch1 cch2 pre_test ## Min. :1.000 Min. :0.000 Min. :0.00 Min. : 0.000 ## 1st Qu.:1.000 1st Qu.:1.000 1st Qu.:1.00 1st Qu.: 4.000 ## Median :1.000 Median :1.000 Median :2.00 Median : 6.000 ## Mean :1.302 Mean :1.137 Mean :1.66 Mean : 6.015 ## 3rd Qu.:2.000 3rd Qu.:2.000 3rd Qu.:2.00 3rd Qu.: 9.000 ## Max. :2.000 Max. :3.000 Max. :3.00 Max. :16.000 ## NA&#39;s :79 NA&#39;s :81 NA&#39;s :79 ## post_test ccprod1 ccprod2 ccrdr1 ## Min. : 0.000 Min. : 0.000 Min. : 0.000 Min. :0.0000 ## 1st Qu.: 6.000 1st Qu.: 2.000 1st Qu.: 3.000 1st Qu.:0.0000 ## Median : 9.000 Median : 4.000 Median : 5.000 Median :0.0000 ## Mean : 8.601 Mean : 3.918 Mean : 4.911 Mean :0.8628 ## 3rd Qu.:11.000 3rd Qu.: 6.000 3rd Qu.: 7.000 3rd Qu.:1.0000 ## Max. :15.000 Max. :17.000 Max. :19.000 Max. :8.0000 ## NA&#39;s :81 NA&#39;s :79 NA&#39;s :81 NA&#39;s :79 ## ccrdr2 grade CSIW ## Min. : 0.000 Min. :1.000 Min. :0.0000 ## 1st Qu.: 0.000 1st Qu.:1.000 1st Qu.:0.0000 ## Median : 1.000 Median :1.000 Median :1.0000 ## Mean : 2.477 Mean :1.471 Mean :0.6978 ## 3rd Qu.: 3.000 3rd Qu.:2.000 3rd Qu.:1.0000 ## Max. :12.000 Max. :2.000 Max. :1.0000 ## NA&#39;s :82 NA&#39;s :40 codebook(csiw) knitr::asis_output(data_info) 2.1.1 Metadata 2.1.1.1 Description if (exists(&quot;name&quot;, meta)) { glue::glue( &quot;__Dataset name__: {name}&quot;, .envir = meta) } Dataset name: csiw cat(description) The dataset has N=407 rows and 15 columns. 258 rows have no missing values on any column. Metadata for search engines Date published: 2019-04-29 meta &lt;- meta[setdiff(names(meta), c(&quot;creator&quot;, &quot;datePublished&quot;, &quot;identifier&quot;, &quot;url&quot;, &quot;citation&quot;, &quot;spatialCoverage&quot;, &quot;temporalCoverage&quot;, &quot;description&quot;, &quot;name&quot;))] pander::pander(meta) keywords: school, teacher, id, group, treatmt, cch1, cch2, pre_test, post_test, ccprod1, ccprod2, ccrdr1, ccrdr2, grade and CSIW knitr::asis_output(survey_overview) 2.2 Variables if (detailed_variables || detailed_scales) { knitr::asis_output(paste0(scales_items, sep = &quot;\\n\\n\\n&quot;, collapse = &quot;\\n\\n\\n&quot;)) } 2.2.1 school school id 2.2.1.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 0 missing values. 2.2.1.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss school school id numeric 0 407 407 4.51 3.95 1 1 2 9 13 ▇▁▁▁▁▃▁▁ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } 2.2.2 teacher teacher id 2.2.2.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 0 missing values. 2.2.2.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss teacher teacher id numeric 0 407 407 10.91 7.71 1 4 8 18 55 ▇▃▅▂▁▁▁▁ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } 2.2.3 id student id 2.2.3.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 0 missing values. 2.2.3.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss id student id numeric 0 407 407 32.12 15.7 1 20 35 44 61 ▃▃▂▃▇▆▅▂ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } 2.2.4 group Achievement Level 2.2.4.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 40 missing values. 2.2.4.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type value_labels missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss group Achievement Level numeric 1. High achieving,2. Average achieving,3. Low achieving,4. Learning disabled 40 367 407 2.66 1.17 1 2 3 4 4 ▆▁▅▁▁▅▁▇ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } 2.2.4.3 Value labels if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } High achieving: 1 Average achieving: 2 Low achieving: 3 Learning disabled: 4 2.2.5 treatmt treatment condition 2.2.5.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 0 missing values. 2.2.5.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type value_labels missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss treatmt treatment condition numeric 1. Experimental,2. Control 0 407 407 1.3 0.46 1 1 1 2 2 ▇▁▁▁▁▁▁▃ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } 2.2.5.3 Value labels if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } Experimental: 1 Control: 2 2.2.6 cch1 holistic, pretest 2.2.6.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 79 missing values. 2.2.6.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss cch1 holistic, pretest numeric 79 328 407 1.14 0.76 0 1 1 2 3 ▃▁▇▁▁▆▁▁ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } 2.2.7 cch2 holistic, posttest 2.2.7.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 81 missing values. 2.2.7.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss cch2 holistic, posttest numeric 81 326 407 1.66 0.75 0 1 2 2 3 ▁▁▅▁▁▇▁▂ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } 2.2.8 pre_test pre_test 2.2.8.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 79 missing values. 2.2.8.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss pre_test pre_test numeric 79 328 407 6.02 3.62 0 4 6 9 16 ▆▃▇▆▅▃▁▁ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } 2.2.9 post_test post_test 2.2.9.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 81 missing values. 2.2.9.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss post_test post_test numeric 81 326 407 8.6 3.56 0 6 9 11 15 ▂▂▅▆▆▇▆▃ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } 2.2.10 ccprod1 productivity, pretest 2.2.10.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 79 missing values. 2.2.10.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss ccprod1 productivity, pretest numeric 79 328 407 3.92 3.22 0 2 4 6 17 ▇▅▃▂▂▁▁▁ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } 2.2.11 ccprod2 productivity, posttest 2.2.11.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 81 missing values. 2.2.11.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss ccprod2 productivity, posttest numeric 81 326 407 4.91 2.98 0 3 5 7 19 ▅▆▇▂▁▁▁▁ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } 2.2.12 ccrdr1 sensitivity, pretest 2.2.12.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 79 missing values. 2.2.12.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss ccrdr1 r. sensitivity, pretest numeric 79 328 407 0.86 1.33 0 0 0 1 8 ▇▁▁▁▁▁▁▁ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } 2.2.13 ccrdr2 sensitivity, posttest 2.2.13.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 82 missing values. 2.2.13.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss ccrdr2 r. sensitivity, posttest numeric 82 325 407 2.48 3.45 0 0 1 3 12 ▇▂▁▁▁▁▁▁ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } 2.2.14 grade grade 2.2.14.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 40 missing values. 2.2.14.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name label data_type value_labels missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss grade grade numeric 1. Fourth grade,2. Fifth grade 40 367 407 1.47 0.5 1 1 1 2 2 ▇▁▁▁▁▁▁▇ F2.0 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } 2.2.14.3 Value labels if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } Fourth grade: 1 Fifth grade: 2 2.2.15 CSIW 2.2.15.1 Distribution show_missing_values &lt;- FALSE if (has_labels(item)) { missing_values &lt;- item[is.na(haven::zap_missing(item))] attributes(missing_values) &lt;- attributes(item) if (!is.null(attributes(item)$labels)) { attributes(missing_values)$labels &lt;- attributes(missing_values)$labels[is.na(attributes(missing_values)$labels)] attributes(item)$labels &lt;- attributes(item)$labels[!is.na(attributes(item)$labels)] } if (is.double(item)) { show_missing_values &lt;- length(unique(haven::na_tag(missing_values))) &gt; 1 item &lt;- haven::zap_missing(item) } if (length(item_attributes$labels) == 0 &amp;&amp; is.numeric(item)) { item &lt;- haven::zap_labels(item) } } item_nomiss &lt;- item[!is.na(item)] # unnest mc_multiple and so on if ( is.character(item_nomiss) &amp;&amp; any(stringr::str_detect(item_nomiss, stringr::fixed(&quot;, &quot;))) &amp;&amp; !is.null(item_info) &amp;&amp; (exists(&quot;type&quot;, item_info) &amp;&amp; any(stringr::str_detect(item_info$type, pattern = stringr::fixed(&quot;multiple&quot;)))) ) { item_nomiss &lt;- unlist(stringr::str_split(item_nomiss, pattern = stringr::fixed(&quot;, &quot;))) } attributes(item_nomiss) &lt;- attributes(item) old_height &lt;- knitr::opts_chunk$get(&quot;fig.height&quot;) non_missing_choices &lt;- item_attributes[[&quot;labels&quot;]] many_labels &lt;- length(non_missing_choices) &gt; 7 go_vertical &lt;- !is_numeric_or_time_var(item_nomiss) || many_labels if ( go_vertical ) { # numeric items are plotted horizontally (because that&#39;s what usually expected) # categorical items are plotted vertically because we can use the screen real estate better this way if (is.null(choices) || dplyr::n_distinct(item_nomiss) &gt; length(non_missing_choices)) { non_missing_choices &lt;- unique(item_nomiss) names(non_missing_choices) &lt;- non_missing_choices } choice_multiplier &lt;- old_height/6.5 new_height &lt;- 2 + choice_multiplier * length(non_missing_choices) new_height &lt;- ifelse(new_height &gt; 20, 20, new_height) new_height &lt;- ifelse(new_height &lt; 1, 1, new_height) if(could_disclose_unique_values(item_nomiss) &amp;&amp; is.character(item_nomiss)) { new_height &lt;- old_height } knitr::opts_chunk$set(fig.height = new_height) } wrap_at &lt;- knitr::opts_chunk$get(&quot;fig.width&quot;) * 10 # todo: if there are free-text choices mingled in with the pre-defined ones, don&#39;t show # todo: show rare items if they are pre-defined # todo: bin rare responses into &quot;other category&quot; if (!length(item_nomiss)) { cat(&quot;No non-missing values to show.&quot;) } else if (!could_disclose_unique_values(item_nomiss)) { plot_labelled(item_nomiss, item_name, wrap_at, go_vertical) } else { if (is.character(item_nomiss)) { char_count &lt;- stringr::str_count(item_nomiss) attributes(char_count)$label &lt;- item_label plot_labelled(char_count, item_name, wrap_at, FALSE, trans = &quot;log1p&quot;, &quot;characters&quot;) } else { cat(dplyr::n_distinct(item_nomiss), &quot; unique, categorical values, so not shown.&quot;) } } knitr::opts_chunk$set(fig.height = old_height) 0 missing values. 2.2.15.2 Summary statistics attributes(item) &lt;- item_attributes df = data.frame(item, stringsAsFactors = FALSE) names(df) = html_item_name escaped_table(codebook_table(df)) name data_type missing complete n mean sd p0 p25 p50 p75 p100 hist format.spss display_width CSIW numeric 0 407 407 0.7 0.46 0 0 1 1 1 ▃▁▁▁▁▁▁▇ F8.2 10 if (show_missing_values) { plot_labelled(missing_values, item_name, wrap_at) } if (!is.null(item_info)) { # don&#39;t show choices again, if they&#39;re basically same thing as value labels if (!is.null(choices) &amp;&amp; !is.null(item_info$choices) &amp;&amp; all(names(na.omit(choices)) == item_info$choices) &amp;&amp; all(na.omit(choices) == names(item_info$choices))) { item_info$choices &lt;- NULL } item_info$label_parsed &lt;- item_info$choice_list &lt;- item_info$study_id &lt;- item_info$id &lt;- NULL pander::pander(item_info) } if (!is.null(choices) &amp;&amp; length(choices) &amp;&amp; length(choices) &lt; 30) { pander::pander(as.list(choices)) } missingness_report 2.3 Missingness report if (length(md_pattern)) { if (knitr::is_html_output()) { rmarkdown::paged_table(md_pattern, options = list(rows.print = 10)) } else { knitr::kable(md_pattern) } } items 2.4 Codebook table export_table(metadata_table) jsonld JSON-LD metadata The following JSON-LD can be found by search engines, if you share this codebook publicly on the web. { &quot;name&quot;: &quot;csiw&quot;, &quot;datePublished&quot;: &quot;2019-04-29&quot;, &quot;description&quot;: &quot;The dataset has N=407 rows and 15 columns.\\n258 rows have no missing values on any column.\\n\\n\\n## Table of variables\\nThis table contains variable names, labels, their central tendencies and other attributes.\\n\\n|name |label |data_type |value_labels |missing |complete |n |mean |sd |p0 |p25 |p50 |p75 |p100 |hist |format.spss |display_width |\\n|:---------|:------------------------|:---------|:-------------------------------------------------------------------------------|:-------|:--------|:---|:-----|:----|:--|:---|:---|:---|:----|:--------|:-----------|:-------------|\\n|school |school id |numeric |NA |0 |407 |407 |4.51 |3.95 |1 |1 |2 |9 |13 |▇▁▁▁▁▃▁▁ |F2.0 |NA |\\n|teacher |teacher id |numeric |NA |0 |407 |407 |10.91 |7.71 |1 |4 |8 |18 |55 |▇▃▅▂▁▁▁▁ |F2.0 |NA |\\n|id |student id |numeric |NA |0 |407 |407 |32.12 |15.7 |1 |20 |35 |44 |61 |▃▃▂▃▇▆▅▂ |F2.0 |NA |\\n|group |Achievement Level |numeric |1. High achieving, - 2. Average achieving, - 3. Low achieving, - 4. Learning disabled |40 |367 |407 |2.66 |1.17 |1 |2 |3 |4 |4 |▆▁▅▁▁▅▁▇ |F2.0 |NA |\\n|treatmt |treatment condition |numeric |1. Experimental, - 2. Control |0 |407 |407 |1.3 |0.46 |1 |1 |1 |2 |2 |▇▁▁▁▁▁▁▃ |F2.0 |NA |\\n|cch1 |holistic, pretest |numeric |NA |79 |328 |407 |1.14 |0.76 |0 |1 |1 |2 |3 |▃▁▇▁▁▆▁▁ |F2.0 |NA |\\n|cch2 |holistic, posttest |numeric |NA |81 |326 |407 |1.66 |0.75 |0 |1 |2 |2 |3 |▁▁▅▁▁▇▁▂ |F2.0 |NA |\\n|pre_test |pre_test |numeric |NA |79 |328 |407 |6.02 |3.62 |0 |4 |6 |9 |16 |▆▃▇▆▅▃▁▁ |F2.0 |NA |\\n|post_test |post_test |numeric |NA |81 |326 |407 |8.6 |3.56 |0 |6 |9 |11 |15 |▂▂▅▆▆▇▆▃ |F2.0 |NA |\\n|ccprod1 |productivity, pretest |numeric |NA |79 |328 |407 |3.92 |3.22 |0 |2 |4 |6 |17 |▇▅▃▂▂▁▁▁ |F2.0 |NA |\\n|ccprod2 |productivity, posttest |numeric |NA |81 |326 |407 |4.91 |2.98 |0 |3 |5 |7 |19 |▅▆▇▂▁▁▁▁ |F2.0 |NA |\\n|ccrdr1 |r. sensitivity, pretest |numeric |NA |79 |328 |407 |0.86 |1.33 |0 |0 |0 |1 |8 |▇▁▁▁▁▁▁▁ |F2.0 |NA |\\n|ccrdr2 |r. sensitivity, posttest |numeric |NA |82 |325 |407 |2.48 |3.45 |0 |0 |1 |3 |12 |▇▂▁▁▁▁▁▁ |F2.0 |NA |\\n|grade |grade |numeric |1. Fourth grade, - 2. Fifth grade |40 |367 |407 |1.47 |0.5 |1 |1 |1 |2 |2 |▇▁▁▁▁▁▁▇ |F2.0 |NA |\\n|CSIW |NA |numeric |NA |0 |407 |407 |0.7 |0.46 |0 |0 |1 |1 |1 |▃▁▁▁▁▁▁▇ |F8.2 |10 |\\n\\n### Note\\nThis dataset was automatically described using the [codebook R package](https://rubenarslan.github.io/codebook/) (version 0.8.0).&quot;, &quot;keywords&quot;: [&quot;school&quot;, &quot;teacher&quot;, &quot;id&quot;, &quot;group&quot;, &quot;treatmt&quot;, &quot;cch1&quot;, &quot;cch2&quot;, &quot;pre_test&quot;, &quot;post_test&quot;, &quot;ccprod1&quot;, &quot;ccprod2&quot;, &quot;ccrdr1&quot;, &quot;ccrdr2&quot;, &quot;grade&quot;, &quot;CSIW&quot;], &quot;@context&quot;: &quot;http://schema.org/&quot;, &quot;@type&quot;: &quot;Dataset&quot;, &quot;variableMeasured&quot;: [ { &quot;name&quot;: &quot;school&quot;, &quot;description&quot;: &quot;school id&quot;, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;teacher&quot;, &quot;description&quot;: &quot;teacher id&quot;, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;id&quot;, &quot;description&quot;: &quot;student id&quot;, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;group&quot;, &quot;description&quot;: &quot;Achievement Level&quot;, &quot;value&quot;: &quot;1. High achieving,\\n2. Average achieving,\\n3. Low achieving,\\n4. Learning disabled&quot;, &quot;maxValue&quot;: 4, &quot;minValue&quot;: 1, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;treatmt&quot;, &quot;description&quot;: &quot;treatment condition&quot;, &quot;value&quot;: &quot;1. Experimental,\\n2. Control&quot;, &quot;maxValue&quot;: 2, &quot;minValue&quot;: 1, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;cch1&quot;, &quot;description&quot;: &quot;holistic, pretest&quot;, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;cch2&quot;, &quot;description&quot;: &quot;holistic, posttest&quot;, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;pre_test&quot;, &quot;description&quot;: &quot;pre_test&quot;, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;post_test&quot;, &quot;description&quot;: &quot;post_test&quot;, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;ccprod1&quot;, &quot;description&quot;: &quot;productivity, pretest&quot;, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;ccprod2&quot;, &quot;description&quot;: &quot;productivity, posttest&quot;, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;ccrdr1&quot;, &quot;description&quot;: &quot;r. sensitivity, pretest&quot;, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;ccrdr2&quot;, &quot;description&quot;: &quot;r. sensitivity, posttest&quot;, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;grade&quot;, &quot;description&quot;: &quot;grade&quot;, &quot;value&quot;: &quot;1. Fourth grade,\\n2. Fifth grade&quot;, &quot;maxValue&quot;: 2, &quot;minValue&quot;: 1, &quot;@type&quot;: &quot;propertyValue&quot; }, { &quot;name&quot;: &quot;CSIW&quot;, &quot;@type&quot;: &quot;propertyValue&quot; } ] }` "],
["naive-model.html", "3 Naive Model", " 3 Naive Model "],
["ancova-model.html", "4 ANCOVA Model", " 4 ANCOVA Model "],
["assessing-linearity.html", "5 Assessing Linearity", " 5 Assessing Linearity "],
["quadratic-model.html", "6 Quadratic Model", " 6 Quadratic Model "],
["searching-for-confounders.html", "7 Searching for Confounders", " 7 Searching for Confounders "],
["heterogeneity.html", "8 Heterogeneity", " 8 Heterogeneity "],
["checking-assumptions.html", "9 Checking Assumptions", " 9 Checking Assumptions "],
["conclusion.html", "10 Conclusion", " 10 Conclusion "]
]
